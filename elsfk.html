<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS // SYSTEM PROTOCOL v3.0</title>
    <style>
        /* --- 核心基础 --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            background-image: radial-gradient(circle at 50% 0%, #131b2e 0%, #050510 80%);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #b0b0d0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        /* 主容器 */
        #game-container {
            width: 850px;
            max-width: 95vw;
            border: 1px solid #1f2a48;
            background: rgba(5, 5, 16, 0.9);
            position: relative;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transition: border-color 0.5s;
        }

        /* 装饰线 */
        .deco-line {
            height: 2px;
            width: 100%;
            background: linear-gradient(90deg, transparent, #00d2ff, transparent);
            box-shadow: 0 0 8px #00d2ff;
            opacity: 0.8;
        }

        /* 头部 */
        header {
            padding: 15px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1f2a48;
            background: rgba(0,0,0,0.2);
        }

        h1 {
            color: #fff;
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-badge {
            color: #00d2ff;
            font-size: 11px;
            text-transform: uppercase;
            border: 1px solid rgba(0, 210, 255, 0.3);
            padding: 4px 12px;
            letter-spacing: 2px;
            background: rgba(0, 210, 255, 0.05);
            border-radius: 2px;
        }

        /* 主内容布局 */
        .main-content {
            display: flex;
            padding: 30px;
            gap: 30px;
            justify-content: center;
        }

        /* 侧边栏 */
        .sidebar {
            width: 200px;
            display: flex;
            flex-direction: column;
        }

        .data-panel {
            border-left: 2px solid #1f2a48;
            padding-left: 15px;
            margin-bottom: 25px;
            transition: all 0.3s;
        }
        .data-panel:hover {
            border-left-color: #00d2ff;
            background: linear-gradient(90deg, rgba(0,210,255,0.02), transparent);
        }

        .panel-label {
            color: #00d2ff;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
            letter-spacing: 1.5px;
            opacity: 0.7;
        }

        .score-box {
            font-size: 28px;
            color: #fff;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        .sub-info {
            font-size: 12px;
            color: #667;
            margin-top: 2px;
            font-family: 'Courier New', monospace;
        }

        /* 画布区域 */
        .canvas-wrapper {
            position: relative;
            border: 1px solid #1f2a48;
            padding: 4px;
            background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* 角落装饰 */
        .corner {
            position: absolute;
            width: 6px;
            height: 6px;
            border-color: #00d2ff;
            border-style: solid;
            transition: all 0.3s ease;
            z-index: 2;
            opacity: 0.8;
        }
        .tl { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
        .tr { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
        .bl { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; }
        .br { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

        canvas {
            display: block;
            background-color: #080a15;
            /* 细微的网格线背景 */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* 右侧控件 */
        .controls-sidebar {
            width: 200px;
            text-align: right;
            display: flex;
            flex-direction: column;
        }

        .next-piece-container {
            width: 80px;
            height: 80px;
            border: 1px solid #1f2a48;
            margin-left: auto;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* 按钮样式 */
        .btn {
            background: transparent;
            color: #00d2ff;
            border: 1px solid rgba(31, 42, 72, 0.8);
            border-right: 2px solid #00d2ff;
            padding: 12px 0;
            width: 100%;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            font-family: inherit;
            margin-top: 8px;
            text-transform: uppercase;
            text-align: center;
        }

        .btn:hover {
            background: rgba(0, 210, 255, 0.08);
            border-color: #00d2ff;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.15);
        }

        /* 速度控制 */
        .speed-control {
            margin: 20px 0;
            padding-top: 15px;
            border-top: 1px solid #1f2a48;
        }
        
        .speed-display {
            font-family: 'Courier New', monospace;
            font-size: 20px;
            color: #fff;
            margin: 5px 0 10px 0;
        }

        .speed-buttons {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }

        .mini-btn {
            background: rgba(0,0,0,0.3);
            border: 1px solid #1f2a48;
            color: #00d2ff;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }
        .mini-btn:hover {
            border-color: #00d2ff;
            background: rgba(0, 210, 255, 0.1);
        }

        /* 遮罩层 (Start / Game Over) - 重构版 */
        #overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(5, 5, 16, 0.96); /* 更深，不透明度更高 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }

        /* 默认状态 - 蓝色优雅 */
        .overlay-content {
            text-align: center;
            border: 1px solid #1f2a48;
            padding: 40px 60px;
            background: radial-gradient(circle at top, #131b2e, #050510);
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            position: relative;
        }

        .overlay-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
            background: #00d2ff;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
        }

        .overlay-title {
            font-size: 24px;
            color: #fff;
            font-weight: 300;
            letter-spacing: 6px;
            margin-bottom: 10px;
        }

        .overlay-subtitle {
            font-size: 12px;
            color: #00d2ff;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .overlay-btn {
            background: transparent;
            color: #00d2ff;
            border: 1px solid #00d2ff;
            padding: 10px 40px;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
        }
        .overlay-btn:hover {
            background: #00d2ff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
        }

        /* 失败状态样式 (JS切换) */
        .state-failure .overlay-icon { background: #ff0055; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }
        .state-failure .overlay-subtitle { color: #ff0055; }
        .state-failure .overlay-btn { border-color: #ff0055; color: #ff0055; }
        .state-failure .overlay-btn:hover { background: #ff0055; color: #fff; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }

        /* 键位提示 */
        .key-guide {
            margin-top: auto;
            font-size: 10px;
            color: #556;
            line-height: 2;
        }
        .key {
            border: 1px solid #334;
            padding: 2px 6px;
            border-radius: 2px;
            color: #889;
            margin-left: 5px;
            display: inline-block;
        }

        @media (max-width: 800px) {
            #game-container { width: 100%; height: 100%; border: none; }
            .main-content { flex-direction: column; align-items: center; padding: 15px; }
            .sidebar, .controls-sidebar { width: 100%; text-align: center; flex-direction: row; justify-content: space-around; }
            .data-panel, .speed-control { border: none; margin: 0; }
            .key-guide { display: none; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div class="deco-line"></div>

        <header>
            <h1>
                <!-- 小Logo -->
                <div style="width: 20px; height: 20px; background: #00d2ff; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); display: grid; place-items: center;">
                    <div style="width: 6px; height: 6px; background: #050510;"></div>
                </div>
                TETRIS <span style="font-size: 12px; opacity: 0.5; margin-left: 5px; letter-spacing: 2px;">// PROTOCOL</span>
            </h1>
            <div class="status-badge" id="system-status">STANDBY</div>
        </header>

        <div class="main-content">
            
            <div class="sidebar">
                <div class="data-panel">
                    <span class="panel-label">/// SCORE</span>
                    <div class="score-box" id="score">00000</div>
                    <div class="sub-info" id="high-score">HI: 00000</div>
                </div>
                <div class="data-panel">
                    <span class="panel-label">/// LINES</span>
                    <div class="score-box" id="lines">0</div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <div class="corner tl"></div><div class="corner tr"></div>
                <div class="corner bl"></div><div class="corner br"></div>
                
                <canvas id="tetris" width="240" height="400"></canvas>

                <!-- 遮罩层：初始状态 -->
                <div id="overlay">
                    <div class="overlay-content" id="overlay-content">
                        <div class="overlay-icon">
                            <div style="font-size: 24px; color: #000; font-weight: bold;">T</div>
                        </div>
                        <div class="overlay-title" id="overlay-title">SYSTEM READY</div>
                        <div class="overlay-subtitle" id="overlay-msg">WAITING FOR INPUT</div>
                        <button class="overlay-btn" onclick="startGame()" id="overlay-btn">INITIALIZE</button>
                    </div>
                </div>
            </div>

            <div class="controls-sidebar">
                <span class="panel-label">/// NEXT</span>
                <div class="next-piece-container">
                    <div class="corner tl" style="width: 4px; height: 4px;"></div>
                    <div class="corner br" style="width: 4px; height: 4px;"></div>
                    <canvas id="next" width="80" height="80"></canvas>
                </div>

                <button class="btn" id="btn-pause" onclick="togglePause()">PAUSE</button>

                <div class="speed-control">
                    <span class="panel-label">/// SPEED</span>
                    <div class="speed-display" id="speed-val">800ms</div>
                    <div class="speed-buttons">
                        <button class="mini-btn" onclick="adjustSpeed(1)">-</button>
                        <button class="mini-btn" onclick="adjustSpeed(-1)">+</button>
                    </div>
                </div>

                <div class="key-guide">
                    <div>MOVE <span class="key">←</span> <span class="key">→</span></div>
                    <div>ROTATE <span class="key">↑</span></div>
                    <div>DROP <span class="key">↓</span></div>
                    <div>HARD <span class="key">SPACE</span></div>
                </div>
            </div>
        </div>

        <div class="deco-line" style="margin-top: auto;"></div>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');

        context.scale(20, 20);
        nextContext.scale(20, 20);

        // 颜色配置 (保留霓虹质感)
        const colors = [
            null,
            '#ff0055', // T
            '#00d2ff', // I
            '#aa00ff', // J
            '#ffff00', // O
            '#ffaa00', // L
            '#00ff77', // S
            '#0077ff', // Z
        ];

        // 游戏状态
        let dropCounter = 0;
        let lastTime = 0;
        let isPaused = true;
        let isGameOver = false;
        let animationId = null;

        // 速度配置
        const speedLevels = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100];
        let currentSpeedIdx = 2; // 默认 800ms
        let dropInterval = speedLevels[currentSpeedIdx];

        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            next: null,
            score: 0,
            lines: 0,
            level: 1,
            highScore: 0,
        };

        const arena = createMatrix(12, 20);

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) matrix.push(new Array(w).fill(0));
            return matrix;
        }

        function createPiece(type) {
            if (type === 'I') return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]];
            if (type === 'L') return [[0, 2, 0],[0, 2, 0],[0, 2, 2]];
            if (type === 'J') return [[0, 3, 0],[0, 3, 0],[3, 3, 0]];
            if (type === 'O') return [[4, 4],[4, 4]];
            if (type === 'Z') return [[5, 5, 0],[0, 5, 5],[0, 0, 0]];
            if (type === 'S') return [[0, 6, 6],[6, 6, 0],[0, 0, 0]];
            if (type === 'T') return [[0, 7, 0],[7, 7, 7],[0, 0, 0]];
        }

        function drawBlock(ctx, x, y, colorId, isGhost = false) {
            if (colorId === 0) return;
            const color = colors[colorId];
            
            if (isGhost) {
                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.2;
                ctx.lineWidth = 0.05;
                ctx.strokeRect(x + 0.1, y + 0.1, 0.8, 0.8);
                ctx.globalAlpha = 1.0;
            } else {
                ctx.fillStyle = color;
                // 仅给实体方块加阴影
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillRect(x + 0.1, y + 0.1, 0.8, 0.8);
                
                // 顶部高光
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(x + 0.1, y + 0.1, 0.8, 0.2);
                ctx.shadowBlur = 0;
            }
        }

        function draw() {
            context.fillStyle = '#080a15';
            context.clearRect(0, 0, canvas.width, canvas.height); // Use clearRect for transparency if needed, but here we fill
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            drawMatrix(arena, {x: 0, y: 0}, context);

            if (!isPaused && !isGameOver && player.matrix) {
                // 幽灵方块
                let ghostPos = { ...player.pos };
                while (!collide(arena, { ...player, pos: ghostPos })) {
                    ghostPos.y++;
                }
                ghostPos.y--;
                drawMatrix(player.matrix, ghostPos, context, true);

                // 实体方块
                drawMatrix(player.matrix, player.pos, context);
            }
        }

        function drawMatrix(matrix, offset, ctx, isGhost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x + offset.x, y + offset.y, value, isGhost);
                    }
                });
            });
        }

        function drawNext() {
            nextContext.fillStyle = '#000'; // Pure black for the box
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if(player.next) {
                const offsetX = (4 - player.next[0].length) / 2;
                const offsetY = (4 - player.next.length) / 2;
                drawMatrix(player.next, {x: offsetX, y: offsetY}, nextContext);
            }
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if (y + player.pos.y >= 0 && y + player.pos.y < arena.length) {
                             arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    }
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerHardDrop() {
            if (isPaused || isGameOver) return;
            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--;
            merge(arena, player);
            playerReset();
            arenaSweep();
            updateScore();
            dropCounter = 0;
        }

        function playerMove(offset) {
            player.pos.x += offset;
            if (collide(arena, player)) {
                player.pos.x -= offset;
            }
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            if (player.next === null) {
                player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            }
            player.matrix = player.next;
            player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            drawNext();

            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

            if (collide(arena, player)) {
                gameOver();
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        function collide(arena, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) continue outer;
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                rowCount++;
            }
            if (rowCount > 0) {
                const lineScores = [0, 100, 300, 500, 800];
                player.score += lineScores[rowCount] * player.level;
                player.lines += rowCount;
            }
        }

        // --- 界面与流程控制 ---

        function updateSpeedDisplay() {
            if (currentSpeedIdx < 0) currentSpeedIdx = 0;
            if (currentSpeedIdx >= speedLevels.length) currentSpeedIdx = speedLevels.length - 1;
            dropInterval = speedLevels[currentSpeedIdx];
            document.getElementById('speed-val').innerText = dropInterval + 'ms';
        }

        function adjustSpeed(delta) {
            currentSpeedIdx += delta;
            updateSpeedDisplay();
        }

        function updateScore() {
            document.getElementById('score').innerText = player.score.toString().padStart(5, '0');
            document.getElementById('lines').innerText = player.lines;
            if (player.score > player.highScore) player.highScore = player.score;
            document.getElementById('high-score').innerText = 'HI: ' + player.highScore.toString().padStart(5, '0');
        }

        function updateStatus(text, type = 'normal') {
            const el = document.getElementById('system-status');
            el.innerText = text;
            if (type === 'error') {
                el.style.color = '#ff0055';
                el.style.borderColor = '#ff0055';
                el.style.background = 'rgba(255, 0, 85, 0.1)';
            } else if (type === 'warning') {
                el.style.color = '#ffaa00';
                el.style.borderColor = '#ffaa00';
                el.style.background = 'rgba(255, 170, 0, 0.1)';
            } else {
                el.style.color = '#00d2ff';
                el.style.borderColor = 'rgba(0, 210, 255, 0.3)';
                el.style.background = 'rgba(0, 210, 255, 0.05)';
            }
        }

        function setOverlayState(state) {
            const overlay = document.getElementById('overlay');
            const content = document.getElementById('overlay-content');
            const title = document.getElementById('overlay-title');
            const msg = document.getElementById('overlay-msg');
            const btn = document.getElementById('overlay-btn');

            overlay.style.display = 'flex';
            
            if (state === 'start') {
                content.classList.remove('state-failure');
                title.innerText = "SYSTEM READY";
                msg.innerText = "WAITING FOR INPUT";
                btn.innerText = "INITIALIZE";
            } else if (state === 'gameover') {
                content.classList.add('state-failure');
                title.innerText = "CONNECTION LOST";
                msg.innerText = "FINAL SCORE: " + player.score;
                btn.innerText = "RECONNECT";
            }
        }

        function gameOver() {
            isGameOver = true;
            updateStatus('SYSTEM FAILURE', 'error');
            document.getElementById('game-container').style.borderColor = '#ff0055';
            setOverlayState('gameover');
        }

        function startGame() {
            arena.forEach(row => row.fill(0));
            player.score = 0;
            player.lines = 0;
            player.matrix = null;
            player.next = null;
            
            updateScore();
            updateSpeedDisplay();
            updateStatus('ACTIVE CYCLE');
            document.getElementById('game-container').style.borderColor = '#1f2a48';

            isGameOver = false;
            isPaused = false;
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('btn-pause').innerText = "PAUSE";

            playerReset();
            if (!animationId) update();
        }

        function togglePause() {
            if (isGameOver) return; 
            // 如果在初始界面点暂停，无视
            if (document.getElementById('overlay').style.display !== 'none' && !isPaused) return;

            isPaused = !isPaused;
            if (isPaused) {
                document.getElementById('btn-pause').innerText = "RESUME";
                updateStatus('PAUSED', 'warning');
                context.fillStyle = "rgba(5, 5, 16, 0.6)";
                context.fillRect(0,0,canvas.width, canvas.height);
            } else {
                document.getElementById('btn-pause').innerText = "PAUSE";
                updateStatus('ACTIVE CYCLE');
                update();
            }
        }

        function update(time = 0) {
            if (isPaused || isGameOver) {
                animationId = null; 
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }

            draw();
            animationId = requestAnimationFrame(update);
        }

        document.addEventListener('keydown', event => {
            if (isPaused || isGameOver) return;
            
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate(1);
            else if (event.keyCode === 32) {
                event.preventDefault(); 
                playerHardDrop();
            }
        });

        // 初始化
        draw();
        updateSpeedDisplay();

    </script>
</body>
</html>