<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块</title>
    <style>
        /* --- 基础样式 --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            background-image: radial-gradient(circle at 50% 0%, #131b2e 0%, #050510 80%);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #b0b0d0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        /* 主容器 */
        #game-container {
            width: 850px; /* 稍微加宽以容纳新控件 */
            max-width: 95vw;
            border: 1px solid #1f2a48;
            background: rgba(5, 5, 16, 0.85);
            position: relative;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(8px);
        }

        /* 装饰线条 */
        .deco-line {
            height: 2px;
            width: 100%;
            background: linear-gradient(90deg, transparent, #00d2ff, transparent);
            box-shadow: 0 0 8px #00d2ff;
        }

        /* 头部 */
        header {
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1f2a48;
            background: rgba(0,0,0,0.2);
        }

        h1 {
            color: #fff;
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-badge {
            color: #00d2ff;
            font-size: 11px;
            text-transform: uppercase;
            border: 1px solid #00d2ff;
            padding: 5px 15px;
            letter-spacing: 2px;
            background: rgba(0, 210, 255, 0.05);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
        }

        /* 主体布局 */
        .main-content {
            display: flex;
            padding: 30px;
            gap: 30px;
            justify-content: center;
        }

        /* 侧边栏通用 */
        .sidebar {
            width: 200px;
            display: flex;
            flex-direction: column;
        }

        .data-panel {
            border-left: 2px solid #1f2a48;
            padding-left: 20px;
            margin-bottom: 25px;
            transition: border-color 0.3s;
        }
        
        .data-panel:hover {
            border-left-color: #00d2ff;
        }

        .panel-label {
            color: #00d2ff;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .score-box {
            font-size: 32px;
            color: #fff;
            font-weight: 300;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            font-family: 'Courier New', monospace;
        }

        .sub-info {
            font-size: 13px;
            color: #667;
            margin-top: 4px;
        }

        /* 游戏画布容器 */
        .canvas-wrapper {
            position: relative;
            border: 1px solid #1f2a48;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.05);
            padding: 4px;
            background: #000;
        }

        .corner {
            position: absolute;
            width: 8px;
            height: 8px;
            border-color: #00d2ff;
            border-style: solid;
            transition: all 0.3s ease;
            z-index: 2;
        }
        .tl { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
        .tr { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
        .bl { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; }
        .br { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

        canvas {
            display: block;
            background-color: #080a15;
            background-image: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }

        /* 右侧控件 */
        .controls-sidebar {
            width: 220px;
            text-align: right;
            display: flex;
            flex-direction: column;
        }

        .next-piece-container {
            width: 90px;
            height: 90px;
            border: 1px solid #1f2a48;
            margin-left: auto;
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* 按钮与交互 */
        .btn {
            background: transparent;
            color: #00d2ff;
            border: 1px solid #1f2a48;
            border-right: 2px solid #00d2ff;
            padding: 10px 0;
            width: 100%;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 2px;
            font-family: inherit;
            margin-top: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .btn:hover {
            background: rgba(0, 210, 255, 0.1);
            border-color: #00d2ff;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.2);
        }

        .btn:active {
            transform: translateX(2px);
        }

        /* 速度控制面板 */
        .speed-control {
            margin: 20px 0;
            padding-top: 20px;
            border-top: 1px solid #1f2a48;
        }

        .speed-display {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: #fff;
            margin: 5px 0 10px 0;
            text-shadow: 0 0 5px rgba(0, 210, 255, 0.5);
        }

        .speed-buttons {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }

        .mini-btn {
            background: rgba(0,0,0,0.3);
            border: 1px solid #1f2a48;
            color: #00d2ff;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }
        
        .mini-btn:hover {
            background: #00d2ff;
            color: #000;
        }

        /* 键盘指南 */
        .key-guide {
            margin-top: auto;
            font-size: 11px;
            color: #556;
            line-height: 1.8;
            text-align: right;
        }
        .key {
            border: 1px solid #334;
            padding: 1px 5px;
            border-radius: 2px;
            color: #889;
            margin-left: 5px;
            display: inline-block;
            min-width: 12px;
            text-align: center;
        }

        /* 遮罩层 */
        #overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(5, 5, 16, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .overlay-title {
            font-size: 42px;
            color: #ff0055;
            font-weight: bold;
            text-shadow: 4px 0 #fff, -4px 0 #00d2ff;
            letter-spacing: 6px;
            margin-bottom: 10px;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 0 #fff, -2px 0 #00d2ff; }
            2% { text-shadow: -2px 0 #fff, 2px 0 #00d2ff; transform: skewX(10deg); }
            4% { transform: skewX(0deg); }
            100% { text-shadow: 2px 0 #fff, -2px 0 #00d2ff; }
        }

        /* 响应式 */
        @media (max-width: 800px) {
            .main-content { flex-direction: column; align-items: center; padding: 15px; }
            .sidebar, .controls-sidebar { width: 100%; text-align: center; flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 20px;}
            .data-panel, .speed-control { border: none; margin: 0; }
            .controls-sidebar { text-align: center; }
            .next-piece-container { margin: 0 auto; }
            #game-container { width: 100%; height: 100vh; border: none; }
            .speed-buttons { justify-content: center; }
            .key-guide { display: none; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div class="deco-line"></div>

        <header>
            <h1>
                <!-- 六边形Logo -->
                <div style="width: 24px; height: 24px; background: #00d2ff; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); display: grid; place-items: center;">
                    <div style="width: 8px; height: 8px; background: #050510;"></div>
                </div>
                TETRIS <span style="font-size: 14px; opacity: 0.5; margin-left: 5px;">// PROTOCOL</span>
            </h1>
            <div class="status-badge" id="system-status">SYSTEM READY</div>
        </header>

        <div class="main-content">
            
            <!-- 左侧数据 -->
            <div class="sidebar">
                <div class="data-panel">
                    <span class="panel-label">/// SCORE DATA</span>
                    <div class="score-box" id="score">00000</div>
                    <div class="sub-info" id="high-score">HI: 00000</div>
                </div>

                <div class="data-panel">
                    <span class="panel-label">/// LINES CLEARED</span>
                    <div class="score-box" id="lines" style="font-size: 26px;">0</div>
                </div>
                
                <div class="data-panel">
                    <span class="panel-label">/// DIFFICULTY</span>
                    <div class="score-box" id="level" style="font-size: 26px;">01</div>
                </div>
            </div>

            <!-- 游戏画布 -->
            <div class="canvas-wrapper">
                <div class="corner tl"></div><div class="corner tr"></div>
                <div class="corner bl"></div><div class="corner br"></div>
                
                <canvas id="tetris" width="240" height="400"></canvas>

                <!-- 遮罩层 (Start / Game Over) -->
                <div id="overlay">
                    <div class="overlay-title" id="overlay-title">SYSTEM HALT</div>
                    <p style="color: #fff; margin-bottom: 30px; letter-spacing: 2px;" id="overlay-msg">PRESS START TO INITIATE</p>
                    <button class="btn" style="width: 150px; border-left: 2px solid #00d2ff;" onclick="startGame()">INITIALIZE</button>
                </div>
            </div>

            <!-- 右侧控制 -->
            <div class="controls-sidebar">
                <span class="panel-label">/// NEXT SEQUENCE</span>
                <div class="next-piece-container">
                    <div class="corner tl" style="width: 4px; height: 4px;"></div>
                    <div class="corner br" style="width: 4px; height: 4px;"></div>
                    <canvas id="next" width="80" height="80"></canvas>
                </div>

                <button class="btn" id="btn-pause" onclick="togglePause()">PAUSE SYSTEM</button>

                <!-- 新增：速度控制 -->
                <div class="speed-control">
                    <span class="panel-label">/// VELOCITY OVERRIDE</span>
                    <div class="speed-display" id="speed-val">800ms</div>
                    <div class="speed-buttons">
                        <button class="mini-btn" onclick="adjustSpeed(1)">-</button>
                        <button class="mini-btn" onclick="adjustSpeed(-1)">+</button>
                    </div>
                </div>

                <div class="key-guide">
                    <div>MOVE <span class="key">←</span> <span class="key">→</span></div>
                    <div>ROTATE <span class="key">↑</span></div>
                    <div>SOFT DROP <span class="key">↓</span></div>
                    <div>HARD DROP <span class="key">SPACE</span></div>
                </div>
            </div>
        </div>

        <div class="deco-line" style="margin-top: auto;"></div>
    </div>

    <script>
        // --- 系统配置 ---
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');

        context.scale(20, 20);
        nextContext.scale(20, 20);

        // Cyberpunk 霓虹配色
        const colors = [
            null,
            '#ff0055', // T - Red/Pink
            '#00d2ff', // I - Cyan
            '#aa00ff', // J - Purple
            '#ffff00', // O - Yellow
            '#ffaa00', // L - Orange
            '#00ff77', // S - Green
            '#0077ff', // Z - Blue
        ];

        // 游戏核心变量
        let dropCounter = 0;
        let lastTime = 0;
        let isPaused = true;
        let isGameOver = false;
        let animationId = null;
        
        // 速度设定 (毫秒)
        // 初始速度改为 800，更紧凑
        const speedLevels = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100]; 
        let currentSpeedIdx = 2; // 默认 800ms
        let dropInterval = speedLevels[currentSpeedIdx];

        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            next: null,
            score: 0,
            lines: 0,
            level: 1,
            highScore: 0,
        };

        const arena = createMatrix(12, 20);

        // --- 核心逻辑 ---

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        function createPiece(type) {
            if (type === 'I') {
                return [
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                ];
            } else if (type === 'L') {
                return [
                    [0, 2, 0],
                    [0, 2, 0],
                    [0, 2, 2],
                ];
            } else if (type === 'J') {
                return [
                    [0, 3, 0],
                    [0, 3, 0],
                    [3, 3, 0],
                ];
            } else if (type === 'O') {
                return [
                    [4, 4],
                    [4, 4],
                ];
            } else if (type === 'Z') {
                return [
                    [5, 5, 0],
                    [0, 5, 5],
                    [0, 0, 0],
                ];
            } else if (type === 'S') {
                return [
                    [0, 6, 6],
                    [6, 6, 0],
                    [0, 0, 0],
                ];
            } else if (type === 'T') {
                return [
                    [0, 7, 0],
                    [7, 7, 7],
                    [0, 0, 0],
                ];
            }
        }

        // --- 绘图逻辑 ---

        function drawBlock(ctx, x, y, colorId, isGhost = false) {
            if (colorId === 0) return;
            const color = colors[colorId];
            
            if (isGhost) {
                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 0.05;
                ctx.strokeRect(x + 0.1, y + 0.1, 0.8, 0.8);
                ctx.globalAlpha = 1.0;
            } else {
                ctx.fillStyle = color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillRect(x + 0.1, y + 0.1, 0.8, 0.8);
                
                // 内部高光
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(x + 0.1, y + 0.1, 0.8, 0.2); 
                
                ctx.shadowBlur = 0;
            }
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = 'rgba(31, 42, 72, 0.5)';
            ctx.lineWidth = 0.02;
            ctx.beginPath();
            for (let i = 0; i <= 12; i++) {
                ctx.moveTo(i, 0); ctx.lineTo(i, 20);
            }
            for (let i = 0; i <= 20; i++) {
                ctx.moveTo(0, i); ctx.lineTo(12, i);
            }
            ctx.stroke();
        }

        function draw() {
            // 清除
            context.fillStyle = '#080a15';
            context.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid(context);

            drawMatrix(arena, {x: 0, y: 0}, context);

            if (!isPaused && !isGameOver && player.matrix) {
                // 绘制幽灵方块
                let ghostPos = { ...player.pos };
                while (!collide(arena, { ...player, pos: ghostPos })) {
                    ghostPos.y++;
                }
                ghostPos.y--; // 回退
                drawMatrix(player.matrix, ghostPos, context, true);

                // 绘制当前方块
                drawMatrix(player.matrix, player.pos, context);
            }
        }

        function drawMatrix(matrix, offset, ctx, isGhost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x + offset.x, y + offset.y, value, isGhost);
                    }
                });
            });
        }

        function drawNext() {
            nextContext.fillStyle = '#080a15'; // 也可以透明
            nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if(player.next) {
                const offsetX = (4 - player.next[0].length) / 2;
                const offsetY = (4 - player.next.length) / 2;
                drawMatrix(player.next, {x: offsetX, y: offsetY}, nextContext);
            }
        }

        // --- 游戏逻辑 ---

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // 安全检查：防止写入负数索引导致崩溃
                        if (y + player.pos.y >= 0 && y + player.pos.y < arena.length) {
                             arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    }
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        // 修复后的硬降落：解决Bug
        function playerHardDrop() {
            if (isPaused || isGameOver) return;
            
            // 循环下落直到碰撞
            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--; // 回退到有效位置

            merge(arena, player);
            playerReset();
            arenaSweep();
            updateScore();
            dropCounter = 0; // 重置计时器
        }

        function playerMove(offset) {
            player.pos.x += offset;
            if (collide(arena, player)) {
                player.pos.x -= offset;
            }
        }

        function playerReset() {
            if (player.next === null) {
                const pieces = 'ILJOTSZ';
                player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            }
            player.matrix = player.next;
            const pieces = 'ILJOTSZ';
            player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            drawNext();

            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

            // 如果生成即碰撞，Game Over
            if (collide(arena, player)) {
                gameOver();
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        function collide(arena, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                rowCount++;
            }
            
            if (rowCount > 0) {
                const lineScores = [0, 100, 300, 500, 800];
                player.score += lineScores[rowCount] * player.level;
                player.lines += rowCount;
                player.level = Math.floor(player.lines / 10) + 1;
                
                // 如果当前速度是基于等级自动调整的（可选逻辑，这里我们优先手动控制或混合）
                // 简单起见，升级时不覆盖手动设置的速度，除非我们想做自动加速模式
            }
        }

        // --- 速度控制逻辑 ---
        
        function updateSpeedDisplay() {
            // 安全限制
            if (currentSpeedIdx < 0) currentSpeedIdx = 0;
            if (currentSpeedIdx >= speedLevels.length) currentSpeedIdx = speedLevels.length - 1;
            
            dropInterval = speedLevels[currentSpeedIdx];
            document.getElementById('speed-val').innerText = dropInterval + 'ms';
        }

        function adjustSpeed(delta) {
            // delta: 1 (faster/minus ms) or -1 (slower/plus ms)
            // 注意：数组越小速度越慢(ms越大)，所以逻辑要反一下
            // 用户点击 + (想变快): index++ (ms变小? 不，数组是倒序排列的吗？让我们看看 speedLevels)
            // speedLevels = [1000, 900, ..., 100]; index越大越快
            
            currentSpeedIdx += delta; // +1 变快 (index变大, ms变小)
            updateSpeedDisplay();
        }

        function updateScore() {
            document.getElementById('score').innerText = player.score.toString().padStart(5, '0');
            document.getElementById('lines').innerText = player.lines;
            document.getElementById('level').innerText = player.level.toString().padStart(2, '0');
            
            if (player.score > player.highScore) player.highScore = player.score;
            document.getElementById('high-score').innerText = 'HI: ' + player.highScore.toString().padStart(5, '0');
        }

        // --- 游戏流程控制 ---

        function gameOver() {
            isGameOver = true;
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('overlay-title').innerText = "FATAL ERROR";
            document.getElementById('overlay-title').classList.add("glitch-text");
            document.getElementById('overlay-msg').innerText = "CONNECTION TERMINATED // SCORE: " + player.score;
            document.getElementById('system-status').innerText = 'SYSTEM FAILURE';
            document.getElementById('system-status').style.borderColor = '#ff0055';
            document.getElementById('system-status').style.color = '#ff0055';
            document.getElementById('game-container').style.borderColor = '#ff0055';
        }

        function startGame() {
            arena.forEach(row => row.fill(0));
            player.score = 0;
            player.lines = 0;
            player.level = 1;
            player.matrix = null;
            player.next = null;
            
            updateScore();
            updateSpeedDisplay();

            isGameOver = false;
            isPaused = false;
            
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('system-status').innerText = 'SYSTEM ACTIVE';
            document.getElementById('system-status').style.borderColor = '#00d2ff';
            document.getElementById('system-status').style.color = '#00d2ff';
            document.getElementById('game-container').style.borderColor = '#1f2a48';
            document.getElementById('btn-pause').innerText = "PAUSE SYSTEM";

            playerReset();
            if (!animationId) {
                update();
            }
        }

        function togglePause() {
            if (isGameOver) return; // 游戏结束时不能暂停，只能重开
            if (document.getElementById('overlay').style.display !== 'none' && !isPaused) return; // 初始状态

            isPaused = !isPaused;
            const btn = document.getElementById('btn-pause');
            const status = document.getElementById('system-status');
            
            if (isPaused) {
                btn.innerText = "RESUME";
                status.innerText = "STANDBY MODE";
                status.style.color = "#ffaa00";
                status.style.borderColor = "#ffaa00";
                // 不显示全屏遮罩，只变暗
                context.fillStyle = "rgba(0,0,0,0.5)";
                context.fillRect(0,0,canvas.width, canvas.height);
            } else {
                btn.innerText = "PAUSE SYSTEM";
                status.innerText = "SYSTEM ACTIVE";
                status.style.color = "#00d2ff";
                status.style.borderColor = "#00d2ff";
                update();
            }
        }

        function update(time = 0) {
            if (isPaused || isGameOver) {
                animationId = null; 
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }

            draw();
            animationId = requestAnimationFrame(update);
        }

        // --- 事件监听 ---

        document.addEventListener('keydown', event => {
            if (isPaused || isGameOver) return;
            
            // 键位映射
            if (event.keyCode === 37) { // Left
                playerMove(-1);
            } else if (event.keyCode === 39) { // Right
                playerMove(1);
            } else if (event.keyCode === 40) { // Down
                playerDrop();
            } else if (event.keyCode === 38) { // Up
                playerRotate(1);
            } else if (event.keyCode === 32) { // Space
                // !!! 关键修复：阻止默认滚动行为 !!!
                event.preventDefault(); 
                playerHardDrop();
            }
        });

        // 初始化显示
        drawGrid(context);
        updateSpeedDisplay(); // 初始化速度显示

    </script>
</body>
</html>